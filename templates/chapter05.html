<style>
  h2 {
    counter-increment:count1;
    counter-reset:count2;
  }
  h2:before {
    content:"5." counter(count1) " ";
  }

  h3 {
    counter-increment:count2;
  }
  h3:before {
    content:"5." counter(count1) "." counter(count2) " ";
  }
</style>

<div class="chapter">
<div class="chapter_description">
  <div class="chapter_description_left">
    <img width="100" src="https://cdn-ak.f.st-hatena.com/images/fotolife/p/perlcodesample/20180820/20180820075726.png">  </div>
  <div class="chapter_description_right">
    HTMLをサンプルに正規表現の検索・置換を実践してみましょう。
  </div>
</div>

<h2>JSONデータを入出力するサンプル</h2>

JSONデータを入出力するサンプルプログラムを書いてみます。JSONは、多次元データ構造を表現できるWebで使われるデファクトスタンダードなデータ形式です。

<h3>複数の書籍の情報を表現するJSONデータ</h3>

JSONはUTF-8のテキストとして表現されます。前の章で熱方、書籍のCSVデータは次のようなものでしたが、これをJSONとして表現してみましょう。

<pre>
ID,書名,著者名,価格,発売日
1,Perlテキスト処理プログラミング入門,木本裕紀,2900,2021-01-03
2,Web開発をやるぜPerl,木本裕紀,2000,2021-01-03
3,データベース入門,田中太郎,1900,2019-03-06
</pre>

JSONとして表現したものが以下です。項目名は、英語にして、連想配列の配列というデータ構造で表現しています。

<pre>
[
  {
    "id" : 1,
    "name" : "Perlテキスト処理プログラミング入門",
    "author_name" : "木本裕紀",
    "price" : 2900,
    "issued_date" : "2021-01-03"
  },
  {
    "id" : 2,
    "name" : "Web開発をやるぜPerl",
    "author_name" : "木本裕紀",
    "price" : 2000,
    "issued_date" : "2021-01-03"
  },
  {
    "id" : 3,
    "name" : "データベース入門",
    "author_name" : "田中太郎",
    "price" : 1900,
    "issued_date" : "2019-03-06"
  }
]
</pre>

<h3>JSONデータフォーマットの解説</h3>

JSONのデータフォーマットについて、簡単に解説しておきます。

<h4>数値</h4>

数値は「1」や「1.5」のように表現します。

<pre>
1

1.5
</pre>

<h4>文字列</h4>

文字列はダブルクォート「"」で囲んで表現します。

<pre>
"name"

"Perlテキスト処理プログラミング入門"
</pre>

  {"id" : 1, "name" : "モジガエル"},

配列は「[」と「]」で囲んで「,」で複数の要素を並べます。

<pre>
[3, 5, 7]

["apple", "orange", "banana"]
</pre>

空白や改行は、見やすくするために、自由に使うことができます。

<pre>
[
  3,
  5,
  7
]
</pre>

連想配列を要素にすることもできます。

<pre>
[
  {"id" : 1, "name" : "モジガエル"},
  {"id" : 2, "name" : "サーバー太郎"}
]
</pre>

<h4>連想配列</h4>

連想配列は「{」と「}」で囲んで、キーと値のペアを「,」で複数並べます。キーと値は「:」で繋げます。キーは、文字列である必要があります。Perlのハッシュに該当します。

<pre>
{"id" : 1, "name" : "モジガエル"}
</pre>

もう一度、JSONデータ構造を見てみましょう。配列の要素として、連想配列を持っているというところをよく見てみます。

<pre>
[
  {
    "id" : 1,
    "name" : "Perlテキスト処理プログラミング入門",
    "author_name" : "木本裕紀",
    "price" : 2900,
    "issued_date" : "2021-01-03"
  },
  {
    "id" : 2,
    "name" : "Web開発をやるぜPerl",
    "author_name" : "木本裕紀",
    "price" : 2000,
    "issued_date" : "2021-01-03"
  },
  {
    "id" : 3,
    "name" : "データベース入門",
    "author_name" : "田中太郎",
    "price" : 1900,
    "issued_date" : "2019-03-06"
  }
]
</pre>

わかりやすくするために、疑似的に表現してみましょう。配列の要素が、連想配列になっているという関係性がわかればOKです。

<pre>
[
  A,
  B,
  C
]

A = {
    "id" : 1,
    "name" : "Perlテキスト処理プログラミング入門",
    "author_name" : "木本裕紀",
    "price" : 2900,
    "issued_date" : "2021-01-03"
  }

B = {
    "id" : 2,
    "name" : "Web開発をやるぜPerl",
    "author_name" : "木本裕紀",
    "price" : 2000,
    "issued_date" : "2021-01-03"
  }

C = {
    "id" : 3,
    "name" : "データベース入門",
    "author_name" : "田中太郎",
    "price" : 1900,
    "issued_date" : "2019-03-06"
  }
</pre>

<h3>JSONデータを読み込んで、データを加工して、出力する</h3>

JSONデータを読み込んで、データを加工して、出力するサンプルコードを書いてみます。

価格のデータに10%の消費税を追加して、保存するという処理にしてみます。

JSONデータを「edit_json_add_price_zei_input.json」という名前で保存します。文字コードはUTF-8にしてください。

<pre>
[
  {
    "id" : 1,
    "name" : "Perlテキスト処理プログラミング入門",
    "author_name" : "木本裕紀",
    "price" : 2900,
    "issued_date" : "2021-01-03"
  },
  {
    "id" : 2,
    "name" : "Web開発をやるぜPerl",
    "author_name" : "木本裕紀",
    "price" : 2000,
    "issued_date" : "2021-01-03"
  },
  {
    "id" : 3,
    "name" : "データベース入門",
    "author_name" : "田中太郎",
    "price" : 1900,
    "issued_date" : "2019-03-06"
  }
]
</pre>

次にJSONを読み込むプログラム「edit_json_add_price_zei.pl」を作成します。

<pre>
use strict;
use warnings;
use utf8;

# JSON::PPを読み込み、encode_json関数とdecode_json関数をインポートする
use JSON::PP 'encode_json', 'decode_json';

# ファイル全部を読み込む
my $in_json;
{
  local $/ = undef;
  $in_json = <>;
}

# deocde_json関数でJSONデータをPerlの内部文字列を含むデータ構造に変換
my $books = decode_json $in_json;

for my $book (@$books) {
  # 書籍の情報を取得
  my $id = $book->{id};
  my $name = $book->{name};
  my $price = $book->{price};
  my $issued_date = $book->{issued_date};
  
  # 税込み価格
  my $price_zeikomi = $price * 1.1;
  
  # 税込み価格で書籍の情報を更新
  
  $book->{price} = $price_zeikomi
}

# encode_json関数でPerlの内部文字列を含むデータ構造をJSONデータに変換
my $out_json = encode_json $books;

# JSONを出力
print $out_json;
</pre>

次のように実行してみましょう。

<pre>
perl edit_json_add_price_zei.pl edit_json_add_price_zei_input.json > edit_json_add_price_zei_output.json
</pre>

出力結果です。出力データには、空白文字と改行が含まれていないので、見づらいですが、価格が税込み価格に更新されているのを確認できます。

<pre>
[{"name":"Perlテキスト処理プログラミング入門","author_name":"木本裕紀","price":3190,"issued_date":"2021-01-03","id":1},{"id":2,"issued_date":"2021-01-03","name":"Web開発をやるぜPerl","author_name":"木本裕紀","price":2200},{"id":3,"issued_date":"2019-03-06","author_name":"田中太郎","name":"データベース入門","price":2090}]
</pre>

<h2>JSONを読み込むソースコードの解説</h2>

JSONを読み込むソースコードを解説していきます。

<h3>JSON::PPモジュールの読み込みと関数のインポート</h3>

まず、JSONデータを扱うために、JSON::PPモジュールを読み込む必要があります。JSON::PPモジュールは、Perlのコアモジュールです。Perl 5.14からコアモジュールになりました。

モジュールとは、特定の機能をまとめたものと考えてください。use文を使って、モジュールを読み込むことができます。

<pre>
# JSON::PPを読み込み、encode_json関数とdecode_json関数をインポートする
use JSON::PP 'encode_json', 'decode_json';
</pre>

モジュールの読み込むときに、必要な関数のインポートも同時に行っています。関数のインポートを行うと、その関数が使えるようになります。

Perlのデータ構造からJSONデータを生成するためにencode_json関数をインポートしています。

JSONデータをPerlのデータ構造にするためにdecode_json関数をインポートしています。

<h3>JSONデータをファイルから読み込みPerlのデータ構造に変換する</h3>

次に、JSONデータをファイルから読み込みPerlのデータ構造に変換します。

<pre>
# ファイル全部を読み込む
my $in_json;
{
  local $/ = undef;
  $in_json = <>;
}
</pre>

ファイルの読み込みは、以前に解説したものと同じです。一つ注意してほしいのはEncodeモジュールのdecode関数で、読み込んだデータをPerlの内部文字列に変換していないところです。これは、decode_json関数が、JSONデータをPerlの内部文字列を含むデータ構造に変換してくれるので、書く必要がないためです。

次に、deocde_json関数でJSONデータをPerlの内部文字列を含むデータ構造に変換します。

<pre>
# deocde_json関数でJSONデータをPerlの内部文字列を含むデータ構造に変換
my $books = decode_json $in_json;
</pre>

$booksは、以下のようなPerlのデータ構造になっています。

<pre>
[
  {
    "id" => 1,
    "name" => "Perlテキスト処理プログラミング入門",
    "author_name" => "木本裕紀",
    "price" => 2900,
    "issued_date" => "2021-01-03"
  },
  {
    "id" => 2,
    "name" => "Web開発をやるぜPerl",
    "author_name" => "木本裕紀",
    "price" => 2000,
    "issued_date" => "2021-01-03"
  },
  {
    "id" => 3,
    "name" => "データベース入門",
    "author_name" => "田中太郎",
    "price" => 1900,
    "issued_date" => "2019-03-06"
  }
]
</pre>

Perlでは、これを理解するのが少し大変です。これは、ハッシュの配列と呼ばれるデータ構造ですが、Perlでは、多次元データ構造を表現するためには、リファレンスと呼ばれる機能を使う必要があります。少し回り道をして、リファレンスについて詳しく解説します。

<h2>リファレンスの作成</h2>

リファレンスについて解説していきます。ここからは、しばらく、日本語の扱いについては、忘れてください。データ構造の出力を簡単に見るために、日本語については、いったんおいておき、Perlでひと手間かかる部分を、最後に解説します。

<h3>リファレンスとは</h3>

Perlにはリファレンスという機能があります。リファレンスは日本語では参照という意味です。

リファレンスを作成するコード「create_scalar_ref.pl」をまず書いてみます。リファレンスは、バックスラッシュ「\」で作成できます。Windowsの場合は「\」マークです。

<pre>
use strict;
use warnings;

# 実際のデータ
my $name = "kimoto";

# リファレンスを作成
my $name_ref = \$name;

# 中身を表示してみるとどうなる?
print "$name_ref\n";
</pre>

実行してみましょう。

<pre>
perl create_scalar_ref.pl
</pre>

自分の実行環境での出力結果です。

<pre>
SCALAR(0x55beb1acea08)
</pre>

リファレンスは、実際のデータの指す矢印のようなものだと最初は理解してください。「$name_ref」は「$name」を指しています。

<pre>
# リファレンスのイメージ
$name_ref -> $name
</pre>

内部的な実装では、「$name_ref」には「$name」のメモリ上の位置を示す数値(アドレス)が代入されています。出力結果に表れた16進数の数字はアドレスです。

「$name」は一つの値を表すスカラ変数ですので、このようなリファレンスをスカラリファレンスと呼びます。

<h3>配列リファレンスの作成</h3>

配列のリファレンスも「\」を使って同じように作成できます。

<pre>
# リファレンスを作成
my $nums_ref = \@nums;
</pre>

リファレンスは、実際のデータの指す矢印のようなものです。「$nums_ref」は「@nums」という配列の実体を指しています。

<pre>
# リファレンスのイメージ
$nums_ref -> @nums
</pre>

配列のリファレンスを作成するサンプル「create_array_ref.pl」です。

<pre>
use strict;
use warnings;

# 実際のデータ
my @nums = (3, 5, 9);

# 配列リファレンスを作成
my $nums_ref = \@nums;

# 中身を表示してみるとどうなる?
print "$nums_ref\n";
</pre>

実行してみましょう。

<pre>
perl create_array_ref.pl
</pre>

自分の実行環境での出力結果です。

<pre>
ARRAY(0x560d5ff19a08)
</pre>

<h3>配列リファレンスを簡単に作成する</h3>

配列リファレンスは、無名配列生成子「[]」と呼ばれる文法を使って、簡単に作成できます。

<pre>
# 無名配列生成子を使って配列リファレンスを簡単に作成。
my $nums_ref = [3, 5, 9];
</pre>

これは、以下の記述と同じになります。配列を作成している部分が省略できてきますね。

<pre>
# 実際のデータ
my @nums = (3, 5, 9);

# 配列リファレンスを作成
my $nums_ref = \@nums;
</pre>

Perlでは「()」と「[]」を区別して読めるようになることが、大切です。

無名配列生成子を使って、配列リファレンスを簡単に作成するサンプル「create_array_ref_simple.pl」です。

<pre>
use strict;
use warnings;

# 無名配列生成子を使って配列リファレンスを簡単に作成
my $nums_ref = [3, 5, 9];

# 中身を表示してみるとどうなる?
print "$nums_ref\n";
</pre>

実行してみましょう。

<pre>
perl create_array_ref_simple.pl
</pre>

自分の実行環境での出力結果です。

<pre>
ARRAY(0x55e35929b398)
</pre>

<h3>ハッシュリファレンスの作成</h3>

ハッシュのリファレンスも「\」を使って同じように作成できます。

<pre>
# リファレンスを作成
my $book_ref = \%book;
</pre>

リファレンスは、実際のデータの指す矢印のようなものです。「$book_ref」は「%book」というハッシュの実体を指しています。

<pre>
# リファレンスのイメージ
$book_ref -> %book
</pre>

ハッシュのリファレンスを作成するサンプル「create_hash_ref.pl」です。

<pre>
use strict;
use warnings;

# 実際のデータ
my %book = (id => 1, name => 'Perl Book');

# ハッシュリファレンスを作成
my $book_ref = \%book;

# 中身を表示してみるとどうなる?
print "$book_ref\n";
</pre>

実行してみましょう。

<pre>
perl create_hash_ref.pl
</pre>

自分の実行環境での出力結果です。

<pre>
HASH(0x560d5ff19a08)
</pre>

<h3>ハッシュリファレンスを簡単に作成する</h3>

ハッシュリファレンスは、無名ハッシュ生成子「{}」と呼ばれる文法を使って、簡単に作成できます。

<pre>
# 無名ハッシュ生成子を使ってハッシュリファレンスを簡単に作成。
my $book_ref = {id => 1, name => 'Perl Book'};
</pre>

これは、以下の記述と同じになります。ハッシュを作成している部分が省略できてきますね。

<pre>
# 実際のデータ
my %book = (id => 1, name => 'Perl Book');

# ハッシュリファレンスを作成
my $book_ref = \%book;
</pre>

Perlでは「()」と「{}」を区別して読めるようになることが、大切です。

無名ハッシュ生成子を使って、ハッシュリファレンスを簡単に作成するサンプル「create_hash_ref_simple.pl」です。

<pre>
use strict;
use warnings;

# 無名ハッシュ生成子を使ってハッシュリファレンスを簡単に作成
my $book_ref = {id => 1, name => 'Perl Book'};

# 中身を表示してみるとどうなる?
print "$book_ref\n";
</pre>

実行してみましょう。

<pre>
perl create_hash_ref_simple.pl
</pre>

自分の実行環境での出力結果です。

<pre>
HASH(0x55e35929b398)
</pre>

<h2>デリファレンス</h2>

<h3>デリファレンスとは</h3>

デリファレンスは、リファレンスの作成と反対になる操作で、リファレンスから実体を取り出す操作のことです。

デリファレンスには、スカラのデリファレンス、配列のデリファレンス、ハッシュのデリファレンスがあります。

<ul>
  <li>スカラのデリファレンス</li>
  <li>配列のデリファレンス</li>
  <li>ハッシュのデリファレンス</li>
</ul>

<h3>スカラのデリファレンス</h3>

スカラのデリファレンスの構文です。

<pre>
${スカラリファレンス}
</pre>

スカラリファレンスをデリファレンスして文字列の実体を取り出すサンプル「deref_scalar.pl」です。

<pre>
use strict;
use warnings;

# 実際のデータ
my $name = "kimoto";

# リファレンスを作成
my $name_ref = \$name;

# スカラのデリファレンスして実体を取り出す
my $name_deref = ${$name_ref};

# 中身を表示してみるとどうなる? 元に戻っていますね。
print "$name_deref\n";
</pre>

実行してみましょう。

<pre>
perl deref_scalar.pl
</pre>

出力結果です。「kimoto」という文字列の内容が出力されています。

<pre>
kimoto
</pre>

スカラデリファレンスの構文は、対象が単なる変数の場合は「{}」を省略できるので、次のように書かれることも多いので覚えておきましょう。

<pre>
# スカラのデリファレンスして実体を取り出す
my $name_deref = $$name_ref;
</pre>

<h3>配列のデリファレンス</h3>

配列のデリファレンスの構文です。

<pre>
@{配列リファレンス}
</pre>

配列リファレンスをデリファレンスして配列の実体を取り出すサンプル「deref_array.pl」です。

<pre>
use strict;
use warnings;

# 実際のデータ
my @nums = (3, 5, 9);

# 配列リファレンスを作成
my $nums_ref = \@nums;

# 配列をデリファレンスして実体を取り出す
my @nums_deref = @{$nums_ref};

# 中身を表示してみるとどうなる? 元に戻っていますね。
print "@nums_deref\n";
</pre>

実行してみましょう。

<pre>
perl deref_array.pl
</pre>

出力結果です。「3」「5」「9」という配列の内容が出力されています。

<pre>
3 5 9
</pre>

配列デリファレンスの構文は、対象が単なる変数の場合は「{}」を省略できるので、次のように書かれることも多いので覚えておきましょう。

<pre>
# 配列のデリファレンス
my @nums_deref = @$nums_ref;
</pre>

<h3>ハッシュのデリファレンス</h3>

ハッシュのデリファレンスの構文です。

<pre>
%{ハッシュリファレンス}
</pre>

ハッシュリファレンスをデリファレンスしてハッシュの実体を取り出すサンプル「deref_hash.pl」です。

<pre>
use strict;
use warnings;

# 実際のデータ
my %book = (id => 1, name => 'Perl Book');

# ハッシュリファレンスを作成
my $book_ref = \%book;

# ハッシュのデリファレンスを行って実体を取り出す
my %book_deref = %{$book_ref};

# 中身を表示してみるとどうなる? 元に戻っていますね。
for my $name (sort keys %book_deref) {
  my $value = $book_deref{$name};
  print "$name : $value\n";
}
</pre>

実行してみましょう。

<pre>
perl deref_hash.pl
</pre>

出力結果です。ハッシュの内容が出力されています。

<pre>
id : 1
name : Perl Book
</pre>

ハッシュデリファレンスの構文は、対象が単なる変数の場合は「{}」を省略できるので、次のように書かれることも多いので覚えておきましょう。

<pre>
# ハッシュのデリファレンスを行って実体を取り出す
my %book_deref = %$book_ref;
</pre>

<h2>リファレンスから要素にアクセスする</h2>

配列の要素やハッシュの値をリファレンスから取り出すための、簡単な記法がPerlでは準備されています。

<h3>配列のリファレンスから要素を取得・設定する</h3>

配列のリファレンスから要素にアクセスするにはアロー演算子「->」を使用します。比較として、配列の要素を取得・設定する方法も記述します。

<pre>
# 配列のリファレンスから要素を取得
$array_ref->[$index]

# 配列のリファレンスから要素を設定
$array_ref->[$index] = 値

# 参考情報

# 配列の要素を取得
$array_ref[$index]

# 配列の要素を設定
$array_ref[$index] = 値
</pre>

配列で要素にアクセスする場合の違いは「->」があるかないかだけですので、Perlのプログラムを読むときは、注意して読んでください。

配列のリファレンスから要素の設定・取得を行うサンプル「access_array_ref.pl」です。

<pre>
use strict;
use warnings;

# 配列のリファレンスを作成
my $nums = [3, 5, 7];

# 配列のリファレンスから要素を取得
my $num = $nums->[2];

print "$num\n";

# 配列のリファレンスから要素を設定
$nums->[1] = 10;

# 配列のリファレンスをデリファレンスして出力
print "@$nums\n";
</pre>

プログラムを実行してみましょう。

<pre>
perl access_array_ref.pl
</pre>

出力結果です。配列のリファレンスから要素の取得と設定ができています。

<pre>
7
3 10 7
</pre>

<h3>ハッシュのリファレンスから要素を取得・設定する</h3>

ハッシュのリファレンスから要素にアクセスするにはアロー演算子「->」を使用します。比較として、ハッシュの要素を取得・設定する方法も記述します。

<pre>
# ハッシュのリファレンスから要素を取得
$hash_ref->{$key}

# ハッシュのリファレンスから要素を設定
$hash_ref->{$key} = 値

# 参考情報

# ハッシュの要素を取得
$hash_ref{$key}

# ハッシュの要素を設定
$hash_ref{$key} = 値
</pre>

ハッシュで要素にアクセスする場合の違いは「->」があるかないかだけですので、Perlのプログラムを読むときは、注意して読んでください。

ハッシュのリファレンスから要素の設定・取得を行うサンプル「access_hash_ref.pl」です。

<pre>
use strict;
use warnings;

# ハッシュのリファレンスを作成
my $book = {id => 1, name => 'Perl Book'};

# ハッシュのリファレンスから要素を取得
my $name = $book->{name};

print "$name\n";

# ハッシュのリファレンスから要素を設定
$book->{id} = 2;

# ハッシュのリファレンスをデリファレンスして出力
for my $key (sort keys %$book) {
  my $value = $book->{$key};
  print "$key : $value\n";
}
</pre>

プログラムを実行してみましょう。

<pre>
perl access_hash_ref.pl
</pre>

出力結果です。ハッシュのリファレンスから要素の取得と設定ができています。

<pre>
Perl Book
id : 2
name : Perl Book
</pre>
